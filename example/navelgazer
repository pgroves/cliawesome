#!/usr/bin/ruby
#OBake version 0.2

#add all obake code to the load path
$: << '../src/'

require 'rubygems'


require "set"
require "fileutils"
require "pathname"

require "configmanager"


class NavelGazer

	##The ConfigManager will start out as just the definition of
	##NavelGazer's command options. Later, the arguments seen on
	##the commandline will be passed to it and reconciled to find
	##the value the user wants for each options. 
	def NavelGazer.initConfigManager() 
		cl_manager = CommandLineManager.new()

		##we need to define where to look for a config file. there
		##are a few possibilities

		##start in the current directory, and keep going to the
		##parent directory until we find a file called 
		#'navelgazer.yml'
		yaml_manager = CrawlUpConfigFile.new("navelgazer.yml")

		##other valid options (uncomment one you want)

		##look in the user's home dir. looks in "~/", unix only!
		#yaml_manager = HomDirConfigFile.new("navelgazer.yml")

		##look in exactly one place
		#yaml_manager = FixedLocationConfigFile.new("/usr/share/navelgazer.yml")

		##don't look for a config file unless specified on the commandline
		#yaml_manager = NoConfigFile.new()

		#the configDef is the main application def. We define
		#the name, summary and yaml_manager here, and then we'll
		#add in the options
		optConf = ConfigDef.new(
			"NavelGazer", #main documentation name of this app
			"This awesome demo prints out the " +
			"values of it's arguments. " +
			"Below are the individual options.", #app synopsis
			cl_manager, yaml_manager)
		
		##############
		##Option A
		##
		##switch option example, has one of two values
		#############
		switchOptA= SwitchDef.new(
			:switchA, #key to look up the option's value later
			"Switch Option A", #name of the option
			"This is a pretty cool example of an option that can be" +
			" one of several values" #synopsis
			)

		#now we can add the valid options for switchOptA
		switchOptA.addCase(
			:switchA_case1, #the value that will be in the final hash if
							#this is the case that was selected for switchA
			"o", #short commandline switch:  -a 
			"case-one", #long commandline name: --case-one
			"This explains how case 1 of Switch A works" #doc for the case
		)
	
		switchOptA.addCase(
			:switchA_case2,
			"t",
			"case-two", 
			"This explains how case 2 of Switch A works"
		)
		
		#it's good practice to have a default for the switch
		switchOptA.setDefault(:switchA_case1)

		#now add switchA to the master list of options
		optConf.addFlagDef(switchOptA)
	
		##############
		##Option B
		##
		##switch option example, has only one possible value (or nil)
		##commandline only
		#############
		switchOptB= SwitchDef.new(
			:switchB, #key to look up the option's value later
			"Switch Option B", #name of the option
			"This is a pretty cool example of an option that can be" +
			" be present, or not" #synopsis
			)

		#now we can add the valid options for switchOptA
		switchOptB.addCase(
			:present, #the value that will be in the final hash if
							#this is the case that was selected for switchA
			"b", #short commandline switch:  -b 
			"switch-b", #long commandline name: --case-one
			"This explains what happens when switchB is set" #doc for the case
		)
		
		switchOptB.setCommandLineOnly()
		#now add switchB to the master list of options
		optConf.addFlagDef(switchOptB)

		##############
		##Option C
		##
		##set a free form value, needs two values
		##config file only and mandatory
		#############

		#sources dir option
		valueOptC= ValueDef.new(
			:valueC, #lookup key 
			"Value Option C", 
			"c", #short name
			"option-c", #long documentation name
			2, #how many arguments there needs to be for this one
			"The long form documetation of option C" 
			)

		valueOptC.setConfigFileOnly()

		#these will show up as example values in the auto generated config file
		valueOptC.setValueDocLabels(["blue", "green", "red"]) 

		#but these two will be uncommented in the autogenerated config file
		valueOptC.setDefault(["blue", "green"]);

		optConf.addFlagDef(valueOptC)

		return optConf
	end


end


if __FILE__ == $0

	#get the configuration definition for this application. It's
	#parameter types are hardcoded, but the value set by the user
	#are initially not set
	configManager = NavelGazer.initConfigManager()

	#pass the configuration object the commandline arguments
	#input into this ruby process. the configuration manager
	#will search the commandline arguments and config file for
	#the hardcoded parameter types.
	configManager.deduceOptions(ARGV)


	##If the user specified "-h" for help or generated a config file,
	##we should not treat this as a real run and just return from the
	##main method now.
	if(configManager.isAdminRun())
		return
	end

	#the options hash has keys that are parameter names, and
	#values are the values observed in the commandline args
	#or config file
	options_hash = configManager.getArgumentHash()

	#the open list contains any space separated strings at the end
	#of the commandline arguments that were not found to be
	#the options in configManager. Typically used for a list
	#of files
	open_list =	configManager.getOpenList()

	#where the config file that was used was actually found. it
	#may be in the home directory, in a 'crawl up' directory, or
	#have been specified by the user on the commandline
	config_file_path = configManager.yaml_manager().getPathname()

	
	puts "Found config file: " + config_file_path.to_s()

	observed_a = options_hash[:switchA]
	observed_b = options_hash[:switchB]
	observed_c = options_hash[:valueC]

	if(observed_a == :switchA_case1)
		puts "Switch A was set to Case 1"
		end
	if(observed_a == :switchA_case2)
		puts "Switch A was set to Case 2"
		end


	if(observed_b == :present)
		puts "Switch B is On"
		end
	if(observed_b.nil?)
		puts "Switch B is Off"
		end

	puts "Values for C are: [#{observed_c[0]}, #{observed_c[1]}]"
	
	puts "The open_list values are:"
	open_list.each do |x|
		puts " - " + x
	end	
		
	end



